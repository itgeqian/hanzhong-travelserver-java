# 汉中旅游服务平台后端项目详解

## 项目概述

汉中旅游服务平台是一个功能完善的旅游综合服务系统后端项目，采用Spring Boot + MyBatis Plus架构，提供完整的旅游服务解决方案。系统包含17个核心业务模块，60+个API接口，涵盖用户管理、景点推荐、酒店预订、美食指南、文化活动、智能推荐等全方位旅游服务功能。

### 核心特性
- **智能推荐系统**: 基于协同过滤算法的景点个性化推荐
- **多端统一接口**: RESTful API设计，支持Web端和移动端
- **完善的用户体系**: 用户注册、登录、权限管理、个人信息管理
- **丰富的业务功能**: 景点预约、酒店订房、美食推荐、文化活动、旅游线路等
- **高性能缓存**: Redis缓存提升系统响应速度
- **安全认证机制**: JWT Token认证，确保接口安全

## 技术栈

### 核心框架
- **Spring Boot 2.4.2**: 主框架，提供自动配置和快速开发
- **MyBatis Plus 3.4.1**: ORM框架，简化数据库操作，支持代码生成器
- **Spring Boot Starter Web**: Web开发支持，提供MVC架构
- **Spring Boot Starter Data Redis**: Redis缓存支持

### 数据库
- **MySQL 8.0+**: 主数据库，存储业务数据
- **Redis 6.0+**: 缓存数据库，用于Token存储和数据缓存
- **Druid 1.2.16**: 数据库连接池，提供监控和性能统计

### 工具库
- **Lombok**: 简化Java代码编写，减少样板代码
- **FastJSON2 2.0.25**: 高性能JSON序列化/反序列化
- **HuTool 5.8.15**: Java工具类库，提供常用工具方法
- **JWT**: Token生成与解析，用户认证
- **Commons工具类**: Apache Commons系列工具包

## 17个核心业务模块详解

### 1. 用户管理模块 (UserController)
**功能概述**: 提供完整的用户生命周期管理

**核心功能**:
- **用户信息管理**: 分页查询、新增、编辑、删除用户
- **个人中心**: 获取登录用户信息、修改个人资料、头像上传
- **密码管理**: 密码重置、修改密码、忘记密码找回
- **邮箱验证**: 注册验证码发送、邮箱验证
- **权限控制**: 用户类型管理（管理员/普通用户）

**技术实现**:
- 密码加盐哈希加密存储
- 头像文件上传处理
- 邮箱验证码机制
- 用户权限分级管理

**接口数量**: 13个核心接口

### 2. 登录认证模块 (LoginController)
**功能概述**: 用户身份认证和会话管理

**核心功能**:
- **用户登录**: 账号密码验证，JWT Token生成
- **登录状态管理**: Token验证、用户登出
- **数据统计**: 管理端统计数据获取

**技术实现**:
- JWT Token生成和验证
- Redis存储用户Token
- 登录状态拦截器
- 最近7天预约数据统计

**接口数量**: 3个核心接口

### 3. 景点管理模块 (SysAttractionsController)
**功能概述**: 景点信息管理和智能推荐

**核心功能**:
- **景点信息管理**: CRUD操作、分页查询、状态管理
- **智能推荐**: 基于用户行为的个性化推荐
- **景点展示**: 首页推荐、详情展示

**技术实现**:
- 协同过滤推荐算法
- 景点状态管理（启用/禁用）
- 图片批量上传处理
- 库存管理（预约扣减）

**数据字段**:
```java
- id: 景点ID
- name: 景点名称
- price: 门票价格
- introduce: 简介
- content: 详细介绍
- num: 库存数量
- images: 景点图片
- state: 状态（0禁用，1启用）
- createTime: 创建时间
```

**接口数量**: 7个核心接口

### 4. 美食管理模块 (SysFoodController)
**功能概述**: 汉中特色美食信息管理

**核心功能**:
- **美食信息管理**: 美食CRUD、分类管理
- **美食推荐**: 特色美食推荐展示
- **价格管理**: 人均消费价格管理

**数据字段**:
```java
- id: 美食ID
- name: 美食名称
- foodType: 美食类型
- price: 人均价格
- recommendLevel: 推荐等级（1-5星）
- introduce: 简介
- content: 详细介绍
- images: 美食图片
- state: 状态
```

**接口数量**: 6个核心接口

### 5. 酒店管理模块 (SysHotelController)
**功能概述**: 酒店信息管理

**核心功能**:
- **酒店信息管理**: 酒店基本信息CRUD
- **地理位置**: 酒店位置、周边景点关联
- **酒店展示**: 酒店列表、详情展示

**数据字段**:
```java
- id: 酒店ID
- name: 酒店名称
- attractions: 周边景点
- phone: 联系电话
- address: 酒店地址
- introduce: 酒店简介
- content: 详细介绍
- images: 酒店图片
```

**接口数量**: 5个核心接口

### 6. 酒店房型管理模块 (SysHotelItemController)
**功能概述**: 酒店房间类型和库存管理

**核心功能**:
- **房型管理**: 房间类型CRUD、价格管理
- **库存管理**: 房间数量、预订扣减
- **房型展示**: 房型列表、详情展示

**数据字段**:
```java
- id: 房型ID
- hotelId: 所属酒店ID
- name: 房型名称
- price: 房间价格
- num: 库存数量
- introduce: 房型介绍
- images: 房型图片
```

**接口数量**: 6个核心接口

### 7. 汉文化活动模块 (SysCultureController)
**功能概述**: 汉中传统文化活动管理

**核心功能**:
- **活动管理**: 文化活动CRUD、分类管理
- **活动推荐**: 传统文化活动推荐
- **活动参与**: 用户活动参与管理

**数据字段**:
```java
- id: 活动ID
- name: 活动名称
- cultureType: 文化类型
- time: 活动时间
- location: 活动地点
- introduce: 活动简介
- content: 详细介绍
- images: 活动图片
```

**接口数量**: 6个核心接口

### 8. 景点预约模块 (SysAttractionOrderController)
**功能概述**: 景点门票预约和订单管理

**核心功能**:
- **预约管理**: 景点预约CRUD、状态跟踪
- **库存控制**: 自动扣减景点库存
- **预约统计**: 预约数据统计分析

**技术实现**:
- 预约时自动扣减景点库存
- 预约状态管理
- 预约人员信息管理
- 预约时间控制

**数据字段**:
```java
- id: 预约ID
- userId: 用户ID
- attractionsId: 景点ID
- num: 预约人数
- time: 预约时间
- people: 预约人员
- totalPrice: 总价格
- state: 预约状态
```

**接口数量**: 5个核心接口

### 9. 酒店预约模块 (SysHotelOrderController)
**功能概述**: 酒店房间预订和订单管理

**核心功能**:
- **房间预订**: 酒店房间预订CRUD
- **库存管理**: 房间库存自动扣减
- **订单跟踪**: 预订状态管理

**数据字段**:
```java
- id: 预订ID
- userId: 用户ID
- hotelId: 酒店ID
- itemId: 房型ID
- num: 预订数量
- startTime: 入住时间
- endTime: 退房时间
- totalPrice: 总价格
```

**接口数量**: 5个核心接口

### 10. 评论管理模块 (SysCommentsController)
**功能概述**: 用户评论和评分系统

**核心功能**:
- **评论管理**: 用户评论CRUD、审核管理
- **评分系统**: 景点评分统计
- **评论展示**: 评论列表、排序显示

**技术实现**:
- 评论内容审核机制
- 评分数据用于推荐算法
- 用户评论权限控制

**接口数量**: 5个核心接口

### 11. 收藏管理模块 (SysFavorController)
**功能概述**: 用户收藏功能

**核心功能**:
- **收藏管理**: 添加/取消收藏、收藏列表
- **收藏状态**: 检查收藏状态
- **个人收藏**: 用户个人收藏管理

**接口数量**: 6个核心接口

### 12. 旅游线路模块 (SysLineController)
**功能概述**: 旅游线路规划和推荐

**核心功能**:
- **线路管理**: 旅游线路CRUD、线路规划
- **线路推荐**: 热门线路推荐
- **地理信息**: 线路地理位置、温度信息

**数据字段**:
```java
- id: 线路ID
- name: 线路名称
- geography: 地理位置
- temperature: 适宜温度
- days: 游玩天数
- price: 线路价格
- introduce: 线路简介
- content: 详细行程
```

**接口数量**: 6个核心接口

### 13. 轮播图管理模块 (SysRotationsController)
**功能概述**: 首页轮播图管理

**核心功能**:
- **轮播图管理**: 轮播图CRUD、排序管理
- **图片展示**: 首页轮播展示

**接口数量**: 6个核心接口

### 14. 资讯管理模块 (SysForumController)
**功能概述**: 旅游资讯和论坛管理

**核心功能**:
- **资讯管理**: 旅游资讯CRUD、分类管理
- **内容发布**: 资讯内容发布和编辑

**接口数量**: 5个核心接口

### 15. 用户留言模块 (SysMessageController)
**功能概述**: 用户反馈和留言管理

**核心功能**:
- **留言管理**: 用户留言CRUD、处理状态
- **反馈处理**: 留言回复和处理

**数据字段**:
```java
- id: 留言ID
- name: 留言人姓名
- email: 邮箱地址
- subject: 留言主题
- content: 留言内容
- handleStatus: 处理状态
- reply: 回复内容
```

**接口数量**: 6个核心接口

### 16. 联系我们模块 (SysContactController)
**功能概述**: 平台联系信息管理

**核心功能**:
- **联系信息管理**: 联系方式CRUD、排序管理
- **信息展示**: 联系信息展示

**接口数量**: 6个核心接口

### 17. 通用功能模块 (CommonController)
**功能概述**: 系统通用功能支持

**核心功能**:
- **文件上传**: 图片、视频、文件上传处理
- **错误处理**: 统一错误页面处理
- **文件管理**: 上传文件路径管理

**支持格式**:
- 图片：jpeg, jpg, png, gif, webp, bmp
- 视频：常见视频格式
- 文件：通用文件格式

**接口数量**: 4个核心接口

## 项目结构详解

### 1. 完整目录结构

```
tourism-backend/
├── src/main/java/com/shanzhu/tourism/
│   ├── BackendApplication.java          # 主启动类
│   ├── config/                          # 配置类目录
│   │   ├── RedisConfig.java            # Redis配置（序列化器配置）
│   │   ├── MyBatisPlusConfig.java      # MyBatis Plus配置（分页插件）
│   │   ├── CorsConfig.java             # 跨域配置（支持前后端分离）
│   │   └── WebMvcConfig.java           # Web MVC配置（拦截器注册）
│   ├── controller/                      # 控制器层（17个业务模块）
│   │   ├── attractions/                # 景点相关接口
│   │   │   └── SysAttractionsController.java
│   │   ├── user/                       # 用户相关接口
│   │   │   ├── UserController.java
│   │   │   └── LoginController.java
│   │   ├── hotel/                      # 酒店相关接口
│   │   │   ├── SysHotelController.java
│   │   │   └── SysHotelItemController.java
│   │   ├── food/                       # 美食相关接口
│   │   │   └── SysFoodController.java
│   │   ├── culture/                    # 汉文化活动接口
│   │   │   └── SysCultureController.java
│   │   ├── order/                      # 订单相关接口
│   │   │   ├── SysAttractionOrderController.java
│   │   │   └── SysHotelOrderController.java
│   │   ├── comments/                   # 评论管理接口
│   │   │   └── SysCommentsController.java
│   │   ├── favor/                      # 收藏管理接口
│   │   │   └── SysFavorController.java
│   │   ├── line/                       # 旅游线路接口
│   │   │   └── SysLineController.java
│   │   ├── forum/                      # 资讯论坛接口
│   │   │   └── SysForumController.java
│   │   ├── message/                    # 用户留言接口
│   │   │   └── SysMessageController.java
│   │   ├── contact/                    # 联系我们接口
│   │   │   └── SysContactController.java
│   │   ├── rotations/                  # 轮播图管理接口
│   │   │   └── SysRotationsController.java
│   │   └── common/                     # 通用功能接口
│   │       └── CommonController.java
│   ├── service/                         # 服务层接口
│   │   ├── impl/                       # 服务层实现
│   │   ├── IUserService.java           # 用户服务接口
│   │   ├── ISysAttractionsService.java # 景点服务接口
│   │   ├── ISysFoodService.java        # 美食服务接口
│   │   ├── ISysHotelService.java       # 酒店服务接口
│   │   └── ...                         # 其他业务服务接口
│   ├── mapper/                          # 数据访问层
│   │   ├── UserMapper.java             # 用户数据访问
│   │   ├── SysAttractionsMapper.java   # 景点数据访问
│   │   ├── SysFoodMapper.java          # 美食数据访问
│   │   ├── SysHotelMapper.java         # 酒店数据访问
│   │   └── ...                         # 其他Mapper接口
│   ├── domain/                          # 实体类
│   │   ├── User.java                   # 用户实体
│   │   ├── SysAttractions.java         # 景点实体
│   │   ├── SysFood.java                # 美食实体
│   │   ├── SysHotel.java               # 酒店实体
│   │   ├── SysHotelItem.java           # 酒店房型实体
│   │   ├── SysCulture.java             # 汉文化活动实体
│   │   ├── SysAttractionOrder.java     # 景点预约实体
│   │   ├── SysHotelOrder.java          # 酒店预约实体
│   │   ├── SysComments.java            # 评论实体
│   │   ├── SysFavor.java               # 收藏实体
│   │   ├── SysLine.java                # 旅游线路实体
│   │   ├── SysRotations.java           # 轮播图实体
│   │   ├── SysForum.java               # 资讯实体
│   │   ├── SysMessage.java             # 留言实体
│   │   ├── SysContact.java             # 联系信息实体
│   │   └── Result.java                 # 统一返回结果实体
│   ├── utils/                           # 工具类
│   │   ├── RedisUtils.java             # Redis操作工具类
│   │   ├── JwtUtil.java                # JWT Token工具类
│   │   ├── PasswordUtils.java          # 密码加密工具类
│   │   ├── FileUtils.java              # 文件处理工具类
│   │   └── recommend/                  # 推荐算法
│   │       ├── CoreMath.java           # 协同过滤核心算法
│   │       ├── RelateDTO.java          # 关联数据传输对象
│   │       └── ProductDTO.java         # 产品数据传输对象
│   ├── interceptor/                     # 拦截器
│   │   └── TokenInterceptor.java       # Token验证拦截器
│   ├── handle/                          # 异常处理
│   │   └── GlobalExceptionHandler.java # 全局异常处理器
│   ├── enums/                          # 枚举类
│   │   ├── UserTypeEnum.java           # 用户类型枚举
│   │   ├── StateEnum.java              # 状态枚举
│   │   └── OrderStatusEnum.java        # 订单状态枚举
│   └── constant/                       # 常量类
│       ├── Constants.java              # 系统常量
│       └── RedisConstants.java         # Redis常量
├── src/main/resources/
│   ├── application.yml                  # 主配置文件
│   ├── application-dev.yml             # 开发环境配置
│   ├── application-prod.yml            # 生产环境配置
│   ├── mapper/                         # MyBatis XML映射文件
│   │   ├── UserMapper.xml              # 用户SQL映射
│   │   ├── SysAttractionsMapper.xml    # 景点SQL映射
│   │   └── ...                         # 其他映射文件
│   ├── mybatis/                        # MyBatis配置
│   │   └── mybatis-config.xml          # MyBatis配置文件
│   ├── static/                         # 静态资源
│   │   ├── upload/                     # 上传文件目录
│   │   │   ├── images/                 # 图片文件
│   │   │   ├── videos/                 # 视频文件
│   │   │   └── files/                  # 其他文件
│   │   └── ...
│   └── logback-spring.xml              # 日志配置
└── pom.xml                             # Maven依赖配置
```

### 2. 核心目录详细说明

#### 2.1 controller 控制器层（17个模块）
控制器层负责接收HTTP请求，参数验证，调用service层处理业务逻辑，返回统一格式的响应结果。

**主要控制器**：
- **UserController**: 用户管理（13个接口）
- **LoginController**: 登录认证（3个接口）
- **SysAttractionsController**: 景点管理（7个接口）
- **SysFoodController**: 美食管理（6个接口）
- **SysHotelController**: 酒店管理（5个接口）
- **SysHotelItemController**: 房型管理（6个接口）
- **SysCultureController**: 汉文化活动（6个接口）
- **SysAttractionOrderController**: 景点预约（5个接口）
- **SysHotelOrderController**: 酒店预约（5个接口）
- **SysCommentsController**: 评论管理（5个接口）
- **SysFavorController**: 收藏管理（6个接口）
- **SysLineController**: 旅游线路（6个接口）
- **SysRotationsController**: 轮播图管理（6个接口）
- **SysForumController**: 资讯管理（5个接口）
- **SysMessageController**: 用户留言（6个接口）
- **SysContactController**: 联系信息（6个接口）
- **CommonController**: 通用功能（4个接口）

**统一返回格式**：
```java
@Data
public class Result {
    private Boolean success;  // 是否成功
    private String message;   // 返回消息
    private Integer code;     // 状态码
    private Object data;      // 返回数据
    
    public static Result success(Object data) {
        Result result = new Result();
        result.setSuccess(true);
        result.setCode(200);
        result.setMessage("操作成功");
        result.setData(data);
        return result;
    }
}
```

#### 2.2 service 服务层
服务层分为接口定义和实现类，负责具体的业务逻辑处理：

**业务逻辑处理**：
- 数据验证和业务规则检查
- 复杂查询条件构建
- 事务管理
- 缓存操作
- 推荐算法调用

**示例服务实现**：
```java
@Service
public class SysAttractionsServiceImpl extends ServiceImpl<SysAttractionsMapper, SysAttractions> 
        implements ISysAttractionsService {
    
    @Autowired
    private RedisUtils redisUtils;
    
    @Override
    public List<SysAttractions> searchAttractions(String userId) {
        // 检查是否启用推荐算法
        if(BooleanUtil.isFalse(userRecommend)){
            // 普通查询
            QueryWrapper<SysAttractions> queryWrapper = new QueryWrapper<>();
            queryWrapper.lambda()
                .eq(SysAttractions::getState, 1)
                .last("limit 3");
            return this.list(queryWrapper);
        } else {
            // 使用智能推荐
            return recommendAttractions(userId);
        }
    }
}
```

#### 2.3 mapper 数据访问层
数据访问层使用MyBatis Plus，继承BaseMapper获得基础CRUD方法：

```java
@Mapper
public interface SysAttractionsMapper extends BaseMapper<SysAttractions> {
    /**
     * 自定义查询方法
     * 可以在XML文件中定义复杂SQL
     */
    List<SysAttractions> selectByCustomCondition(@Param("condition") String condition);
}
```

#### 2.4 domain 实体类
实体类对应数据库表结构，使用Lombok注解简化代码：

```java
@Data
@TableName("sys_attractions")
public class SysAttractions implements Serializable {
    @TableId(value = "id", type = IdType.ASSIGN_ID)
    private String id;
    
    private String name;           // 景点名称
    private Float price;           // 门票价格
    private String introduce;      // 景点简介
    private String content;        // 详细介绍
    private Integer num;           // 库存数量
    private String images;         // 景点图片（逗号分隔）
    private Integer state;         // 状态（0禁用，1启用）
    
    @TableField(fill = FieldFill.INSERT)
    private Date createTime;       // 创建时间
    
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Date updateTime;       // 更新时间
    
    // 分页参数（非数据库字段）
    @TableField(exist = false)
    private Integer pageNumber;
    
    @TableField(exist = false)
    private Integer pageSize;
}
```

## 核心业务流程详解

### 1. 用户注册登录流程

#### 1.1 用户注册流程
```
1. 用户填写注册信息 → 2. 发送邮箱验证码 → 3. 验证验证码 → 4. 密码加密存储 → 5. 注册成功
```

**技术实现**：
```java
@PostMapping("/saveUser")
public Result saveUser(@RequestBody User user) {
    // 1. 参数验证
    if (StringUtils.isBlank(user.getLoginAccount())) {
        return Result.error("登录账号不能为空");
    }
    
    // 2. 检查账号是否已存在
    QueryWrapper<User> queryWrapper = new QueryWrapper<>();
    queryWrapper.lambda().eq(User::getLoginAccount, user.getLoginAccount());
    User existUser = userService.getOne(queryWrapper);
    if (existUser != null) {
        return Result.error("账号已存在");
    }
    
    // 3. 密码加密
    user.setPassword(PasswordUtils.encodePassword(user.getPassword()));
    
    // 4. 设置默认值
    user.setUserType(1); // 普通用户
    user.setStatus(0);   // 正常状态
    
    // 5. 保存用户
    boolean save = userService.save(user);
    return save ? Result.success("注册成功") : Result.error("注册失败");
}
```

#### 1.2 用户登录流程
```
1. 用户输入账号密码 → 2. 验证用户信息 → 3. 生成JWT Token → 4. 存储到Redis → 5. 返回Token
```

**技术实现**：
```java
@PostMapping("/login")
public Result login(@RequestBody User user) {
    // 1. 参数验证
    if (StringUtils.isBlank(user.getLoginAccount()) || StringUtils.isBlank(user.getPassword())) {
        return Result.error("账号或密码不能为空");
    }
    
    // 2. 查询用户
    QueryWrapper<User> queryWrapper = new QueryWrapper<>();
    queryWrapper.lambda().eq(User::getLoginAccount, user.getLoginAccount());
    User loginUser = userService.getOne(queryWrapper);
    
    if (loginUser == null) {
        return Result.error("账号不存在");
    }
    
    // 3. 验证密码
    if (!PasswordUtils.matches(user.getPassword(), loginUser.getPassword())) {
        return Result.error("密码错误");
    }
    
    // 4. 检查用户状态
    if (loginUser.getStatus() == 1) {
        return Result.error("账号已被禁用");
    }
    
    // 5. 生成JWT Token
    String token = JwtUtil.createToken(loginUser.getId(), loginUser.getPassword());
    
    // 6. 存储Token到Redis（24小时过期）
    redisUtils.set(Constants.PREFIX_USER_TOKEN + loginUser.getId(), token, 24 * 60 * 60L);
    
    // 7. 返回Token
    Map<String, Object> data = new HashMap<>();
    data.put("token", token);
    return Result.success(data);
}
```

### 2. 景点预约业务流程

#### 2.1 景点预约完整流程
```
1. 用户选择景点 → 2. 检查库存 → 3. 提交预约信息 → 4. 扣减库存 → 5. 生成订单 → 6. 返回预约结果
```

**技术实现**：
```java
@PostMapping("/saveSysAttractionOrder")
public Result saveSysAttractionOrder(@RequestBody SysAttractionOrder order) {
    // 1. 获取当前登录用户
    String userId = JwtUtil.getUserIdByToken(request);
    order.setUserId(userId);
    
    // 2. 查询景点信息
    SysAttractions attractions = sysAttractionsService.getById(order.getAttractionsId());
    if (attractions == null) {
        return Result.error("景点不存在");
    }
    
    // 3. 检查景点状态
    if (attractions.getState() != 1) {
        return Result.error("景点已下架");
    }
    
    // 4. 检查库存
    if (attractions.getNum() < order.getNum()) {
        return Result.error("库存不足");
    }
    
    // 5. 计算总价
    BigDecimal totalPrice = attractions.getPrice().multiply(new BigDecimal(order.getNum()));
    order.setTotalPrice(totalPrice);
    
    // 6. 事务处理：保存订单并扣减库存
    boolean result = sysAttractionOrderService.saveOrderAndReduceStock(order, attractions);
    
    return result ? Result.success("预约成功") : Result.error("预约失败");
}

// 事务方法
@Transactional(rollbackFor = Exception.class)
public boolean saveOrderAndReduceStock(SysAttractionOrder order, SysAttractions attractions) {
    // 1. 保存订单
    boolean saveOrder = this.save(order);
    
    // 2. 扣减库存
    attractions.setNum(attractions.getNum() - order.getNum());
    boolean updateStock = sysAttractionsService.updateById(attractions);
    
    return saveOrder && updateStock;
}
```

### 3. 智能推荐算法流程

#### 3.1 协同过滤推荐流程
```
1. 收集用户评分数据 → 2. 计算用户相似度 → 3. 找出相似用户 → 4. 推荐相似用户喜欢的景点 → 5. 返回推荐结果
```

**技术实现**：
```java
private List<SysAttractions> recommendAttractions(String userId) {
    CoreMath coreMath = new CoreMath();
    
    // 1. 生成用户-景点评分关系数据
    List<RelateDTO> relateDTOList = generateRelates();
    
    // 2. 执行推荐算法
    List<String> recommendations = coreMath.recommend(userId, relateDTOList);
    
    // 3. 获取推荐的景点信息
    List<ProductDTO> productDTOList = generateProducts().stream()
            .filter(e -> recommendations.contains(e.getProductId()))
            .collect(Collectors.toList());
    
    // 4. 按推荐度排序
    List<String> productIdList = productDTOList.stream()
            .sorted((o1, o2) -> recommendations.indexOf(o1.getProductId()) - recommendations.indexOf(o2.getProductId()))
            .map(ProductDTO::getProductId)
            .collect(Collectors.toList());
    
    // 5. 查询景点详细信息
    List<SysAttractions> result = new ArrayList<>();
    for (String productId : productIdList) {
        SysAttractions attractions = sysAttractionsMapper.selectById(productId);
        if (attractions != null && attractions.getState() == 1) {
            result.add(attractions);
        }
    }
    
    return result;
}

/**
 * 生成用户-景点评分关系数据
 */
private List<RelateDTO> generateRelates() {
    List<RelateDTO> relateDTOList = new ArrayList<>();
    
    // 从评论表获取用户评分数据
    List<SysComments> commentsList = sysCommentsService.list();
    
    for (SysComments comment : commentsList) {
        RelateDTO relateDTO = new RelateDTO();
        relateDTO.setUserId(comment.getUserId());
        relateDTO.setProductId(comment.getAttractionsId());
        relateDTO.setIndex(comment.getRate().doubleValue()); // 评分作为相关度
        relateDTOList.add(relateDTO);
    }
    
    return relateDTOList;
}
```

### 4. 文件上传处理流程

#### 4.1 图片上传流程
```
1. 接收上传文件 → 2. 验证文件类型 → 3. 生成唯一文件名 → 4. 保存文件 → 5. 返回文件路径
```

**技术实现**：
```java
@PostMapping("/uploadImg")
public Result uploadImg(@RequestParam("file") MultipartFile file) {
    if (file.isEmpty()) {
        return Result.error("请选择要上传的文件");
    }
    
    // 1. 获取原始文件名
    String originalFilename = file.getOriginalFilename();
    
    // 2. 验证文件类型
    String suffix = originalFilename.substring(originalFilename.lastIndexOf("."));
    List<String> allowTypes = Arrays.asList(".jpeg", ".jpg", ".png", ".gif", ".webp", ".bmp");
    if (!allowTypes.contains(suffix.toLowerCase())) {
        return Result.error("不支持的文件类型");
    }
    
    // 3. 生成唯一文件名
    String fileName = UUID.randomUUID().toString() + suffix;
    
    // 4. 创建上传目录
    String uploadPath = "static/upload/images/";
    File uploadDir = new File(uploadPath);
    if (!uploadDir.exists()) {
        uploadDir.mkdirs();
    }
    
    // 5. 保存文件
    try {
        File targetFile = new File(uploadDir, fileName);
        file.transferTo(targetFile);
        
        // 6. 返回相对路径
        String relativePath = "/upload/images/" + fileName;
        return Result.success(relativePath);
    } catch (IOException e) {
        return Result.error("文件上传失败");
    }
}
```

## Redis使用详解

### 1. Redis在项目中的核心作用

#### 1.1 用户认证Token存储
Redis作为分布式缓存，存储用户JWT Token，实现无状态认证：

```java
// 登录成功后存储Token（24小时过期）
public void storeUserToken(String userId, String token) {
    String key = Constants.PREFIX_USER_TOKEN + userId;
    redisUtils.set(key, token, 24 * 60 * 60L); // 24小时
}

// Token验证时获取
public String getUserToken(String userId) {
    String key = Constants.PREFIX_USER_TOKEN + userId;
    return redisUtils.get(key);
}

// 用户登出时删除Token
public void removeUserToken(String userId) {
    String key = Constants.PREFIX_USER_TOKEN + userId;
    redisUtils.remove(key);
}
```

#### 1.2 热点数据缓存
缓存频繁查询的数据，减少数据库压力：

```java
// 缓存景点信息（1小时过期）
public SysAttractions getCachedAttractions(String attractionsId) {
    String key = "attractions:" + attractionsId;
    String cachedData = redisUtils.get(key);
    
    if (cachedData != null) {
        return JSON.parseObject(cachedData, SysAttractions.class);
    }
    
    // 缓存未命中，查询数据库
    SysAttractions attractions = sysAttractionsMapper.selectById(attractionsId);
    if (attractions != null) {
        redisUtils.set(key, JSON.toJSONString(attractions), 3600L); // 1小时
    }
    
    return attractions;
}

// 缓存用户信息
public User getCachedUser(String userId) {
    String key = "user:" + userId;
    String cachedUser = redisUtils.get(key);
    
    if (cachedUser != null) {
        return JSON.parseObject(cachedUser, User.class);
    }
    
    User user = userMapper.selectById(userId);
    if (user != null) {
        // 敏感信息不缓存
        user.setPassword(null);
        redisUtils.set(key, JSON.toJSONString(user), 1800L); // 30分钟
    }
    
    return user;
}
```

#### 1.3 推荐算法缓存
缓存推荐算法结果，提高推荐响应速度：

```java
// 缓存用户推荐结果（2小时过期）
public List<SysAttractions> getCachedRecommendations(String userId) {
    String key = "recommend:attractions:" + userId;
    String cachedData = redisUtils.get(key);
    
    if (cachedData != null) {
        return JSON.parseArray(cachedData, SysAttractions.class);
    }
    
    // 执行推荐算法
    List<SysAttractions> recommendations = executeRecommendAlgorithm(userId);
    
    // 缓存结果
    redisUtils.set(key, JSON.toJSONString(recommendations), 7200L); // 2小时
    
    return recommendations;
}
```

#### 1.4 统计数据缓存
缓存统计数据，支持实时数据展示：

```java
// 缓存预约统计数据
public Map<String, Object> getCachedStatistics() {
    String key = "statistics:orders";
    String cachedData = redisUtils.get(key);
    
    if (cachedData != null) {
        return JSON.parseObject(cachedData, Map.class);
    }
    
    // 计算统计数据
    Map<String, Object> statistics = calculateStatistics();
    
    // 缓存10分钟
    redisUtils.set(key, JSON.toJSONString(statistics), 600L);
    
    return statistics;
}
```

### 2. Redis配置优化

#### 2.1 Redis连接配置
```yaml
# application-dev.yml
spring:
  redis:
    host: 127.0.0.1
    port: 6379
    database: 0
    password: 
    timeout: 10s
    lettuce:
      pool:
        min-idle: 0      # 最小空闲连接
        max-idle: 8      # 最大空闲连接
        max-active: 8    # 最大活跃连接
        max-wait: -1ms   # 最大等待时间
    # 连接超时时间
    connect-timeout: 10s
    # 命令执行超时时间
    command-timeout: 10s
```

#### 2.2 Redis序列化配置
```java
@Configuration
public class RedisConfig {
    
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);
        
        // 使用String序列化器
        StringRedisSerializer stringSerializer = new StringRedisSerializer();
        
        // key和hashKey使用String序列化
        template.setKeySerializer(stringSerializer);
        template.setHashKeySerializer(stringSerializer);
        
        // value和hashValue使用JSON序列化
        GenericJackson2JsonRedisSerializer jsonSerializer = 
            new GenericJackson2JsonRedisSerializer();
        template.setValueSerializer(jsonSerializer);
        template.setHashValueSerializer(jsonSerializer);
        
        template.afterPropertiesSet();
        return template;
    }
}
```

### 3. RedisUtils工具类完整实现

```java
@Component
public class RedisUtils {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    /**
     * 普通缓存获取
     */
    public Object get(String key) {
        return key == null ? null : redisTemplate.opsForValue().get(key);
    }
    
    /**
     * 普通缓存放入
     */
    public boolean set(String key, Object value) {
        try {
            redisTemplate.opsForValue().set(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }
    
    /**
     * 普通缓存放入并设置时间
     */
    public boolean set(String key, Object value, long time) {
        try {
            if (time > 0) {
                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);
            } else {
                set(key, value);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }
    
    /**
     * 删除缓存
     */
    public void del(String... key) {
        if (key != null && key.length > 0) {
            if (key.length == 1) {
                redisTemplate.delete(key[0]);
            } else {
                redisTemplate.delete(Arrays.asList(key));
            }
        }
    }
    
    /**
     * 判断key是否存在
     */
    public boolean hasKey(String key) {
        try {
            return redisTemplate.hasKey(key);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }
    
    /**
     * 递增
     */
    public long incr(String key, long delta) {
        if (delta < 0) {
            throw new RuntimeException("递增因子必须大于0");
        }
        return redisTemplate.opsForValue().increment(key, delta);
    }
    
    /**
     * 递减
     */
    public long decr(String key, long delta) {
        if (delta < 0) {
            throw new RuntimeException("递减因子必须大于0");
        }
        return redisTemplate.opsForValue().increment(key, -delta);
    }
}
```

## 安全机制详解

### 1. 用户认证体系

#### 1.1 密码安全策略
项目采用多层密码保护机制：

```java
@Component
public class PasswordUtils {
    
    private static final String SALT = "shanzhu_tourism_2024";
    
    /**
     * 密码加密（加盐哈希）
     */
    public static String encodePassword(String rawPassword) {
        // 使用BCrypt算法加密
        return BCrypt.hashpw(rawPassword + SALT, BCrypt.gensalt(12));
    }
    
    /**
     * 密码验证
     */
    public static boolean matches(String rawPassword, String encodedPassword) {
        return BCrypt.checkpw(rawPassword + SALT, encodedPassword);
    }
    
    /**
     * 密码强度验证
     */
    public static boolean validatePasswordStrength(String password) {
        if (password == null || password.length() < 6) {
            return false;
        }
        
        // 至少包含字母和数字
        boolean hasLetter = password.matches(".*[a-zA-Z].*");
        boolean hasDigit = password.matches(".*\\d.*");
        
        return hasLetter && hasDigit;
    }
}
```

#### 1.2 JWT Token机制
```java
@Component
public class JwtUtil {
    
    private static final String SECRET = "shanzhu_tourism_jwt_secret_2024";
    private static final long EXPIRE_TIME = 24 * 60 * 60 * 1000; // 24小时
    
    /**
     * 生成Token
     */
    public static String createToken(String userId, String password) {
        try {
            Date date = new Date(System.currentTimeMillis() + EXPIRE_TIME);
            Algorithm algorithm = Algorithm.HMAC256(password + SECRET);
            
            return JWT.create()
                    .withClaim("userId", userId)
                    .withExpiresAt(date)
                    .withIssuedAt(new Date())
                    .sign(algorithm);
        } catch (Exception e) {
            return null;
        }
    }
    
    /**
     * 验证Token
     */
    public static boolean verify(String token, String userId, String password) {
        try {
            Algorithm algorithm = Algorithm.HMAC256(password + SECRET);
            JWTVerifier verifier = JWT.require(algorithm)
                    .withClaim("userId", userId)
                    .build();
            
            DecodedJWT jwt = verifier.verify(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
    
    /**
     * 从Token中获取用户ID
     */
    public static String getUserId(String token) {
        try {
            DecodedJWT jwt = JWT.decode(token);
            return jwt.getClaim("userId").asString();
        } catch (Exception e) {
            return null;
        }
    }
    
    /**
     * 从请求中获取用户ID
     */
    public static String getUserIdByToken(HttpServletRequest request) {
        String token = request.getHeader("Authorization");
        if (token != null && token.startsWith("Bearer ")) {
            token = token.substring(7);
            return getUserId(token);
        }
        return null;
    }
}
```

### 2. 接口权限控制

#### 2.1 Token拦截器
```java
@Component
public class TokenInterceptor implements HandlerInterceptor {
    
    @Autowired
    private RedisUtils redisUtils;
    
    @Autowired
    private IUserService userService;
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, 
                           Object handler) throws Exception {
        
        // 1. 预检请求直接通过
        if ("OPTIONS".equals(request.getMethod())) {
            return true;
        }
        
        // 2. 从请求头获取Token
        String authHeader = request.getHeader("Authorization");
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            return handleUnauthorized(response, "请提供有效的Token");
        }
        
        String token = authHeader.substring(7);
        
        // 3. 解析Token获取用户ID
        String userId = JwtUtil.getUserId(token);
        if (userId == null) {
            return handleUnauthorized(response, "Token格式错误");
        }
        
        // 4. 从Redis获取存储的Token
        String storedToken = redisUtils.get(Constants.PREFIX_USER_TOKEN + userId);
        if (storedToken == null) {
            return handleUnauthorized(response, "登录已过期，请重新登录");
        }
        
        // 5. 验证Token一致性
        if (!token.equals(storedToken)) {
            return handleUnauthorized(response, "Token无效");
        }
        
        // 6. 获取用户信息并验证Token
        User user = userService.getById(userId);
        if (user == null) {
            return handleUnauthorized(response, "用户不存在");
        }
        
        // 7. 验证用户状态
        if (user.getStatus() == 1) {
            return handleUnauthorized(response, "账号已被禁用");
        }
        
        // 8. 验证Token签名
        if (!JwtUtil.verify(token, userId, user.getPassword())) {
            return handleUnauthorized(response, "Token验证失败");
        }
        
        // 9. 将用户信息存储到请求中
        request.setAttribute("currentUser", user);
        
        return true;
    }
    
    private boolean handleUnauthorized(HttpServletResponse response, String message) 
            throws IOException {
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        response.setContentType("application/json;charset=UTF-8");
        
        Map<String, Object> result = new HashMap<>();
        result.put("success", false);
        result.put("code", 401);
        result.put("message", message);
        
        response.getWriter().write(JSON.toJSONString(result));
        return false;
    }
}
```

#### 2.2 跨域配置
```java
@Configuration
public class CorsConfig {
    
    @Bean
    public CorsFilter corsFilter() {
        CorsConfiguration config = new CorsConfiguration();
        
        // 允许所有域名进行跨域调用
        config.addAllowedOriginPattern("*");
        
        // 允许所有请求头
        config.addAllowedHeader("*");
        
        // 允许所有HTTP方法
        config.addAllowedMethod("*");
        
        // 允许发送Cookie
        config.setAllowCredentials(true);
        
        // 预检请求有效期
        config.setMaxAge(3600L);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        
        return new CorsFilter(source);
    }
}
```

### 3. 数据安全保护

#### 3.1 SQL注入防护
使用MyBatis Plus的条件构造器防止SQL注入：

```java
// 安全的查询方式
QueryWrapper<SysAttractions> queryWrapper = new QueryWrapper<>();
queryWrapper.lambda()
    .eq(SysAttractions::getState, 1)
    .like(StringUtils.isNotBlank(name), SysAttractions::getName, name)
    .orderByDesc(SysAttractions::getCreateTime);

List<SysAttractions> list = sysAttractionsService.list(queryWrapper);
```

#### 3.2 参数验证
```java
@PostMapping("/saveSysAttractions")
public Result saveSysAttractions(@RequestBody SysAttractions sysAttractions) {
    // 参数验证
    if (StringUtils.isBlank(sysAttractions.getName())) {
        return Result.error("景点名称不能为空");
    }
    
    if (sysAttractions.getPrice() == null || sysAttractions.getPrice() <= 0) {
        return Result.error("价格必须大于0");
    }
    
    if (sysAttractions.getNum() == null || sysAttractions.getNum() < 0) {
        return Result.error("库存数量不能小于0");
    }
    
    // XSS防护
    sysAttractions.setName(HtmlUtils.htmlEscape(sysAttractions.getName()));
    sysAttractions.setIntroduce(HtmlUtils.htmlEscape(sysAttractions.getIntroduce()));
    
    boolean save = sysAttractionsService.save(sysAttractions);
    return save ? Result.success("保存成功") : Result.error("保存失败");
}
```

#### 3.3 敏感信息处理
```java
// 返回用户信息时隐藏密码
@GetMapping("/getUserInfo")
public Result getUserInfo(HttpServletRequest request) {
    String userId = JwtUtil.getUserIdByToken(request);
    User user = userService.getById(userId);
    
    if (user != null) {
        // 隐藏敏感信息
        user.setPassword(null);
        return Result.success(user);
    }
    
    return Result.error("用户不存在");
}
```

## 数据库设计详解

### 1. 核心业务表结构

#### 1.1 用户表 (sys_user)
```sql
CREATE TABLE `sys_user` (
  `id` varchar(50) NOT NULL COMMENT '用户ID',
  `user_name` varchar(100) DEFAULT NULL COMMENT '用户姓名',
  `login_account` varchar(100) DEFAULT NULL COMMENT '登录账号',
  `password` varchar(255) DEFAULT NULL COMMENT '登录密码',
  `email` varchar(100) DEFAULT NULL COMMENT '邮箱',
  `tel` varchar(20) DEFAULT NULL COMMENT '电话',
  `sex` int(1) DEFAULT NULL COMMENT '性别(0女1男)',
  `user_type` int(1) DEFAULT NULL COMMENT '用户类型(0管理员1普通用户)',
  `status` int(1) DEFAULT '0' COMMENT '用户状态(0正常1禁用)',
  `avatar` varchar(255) DEFAULT NULL COMMENT '头像',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_login_account` (`login_account`),
  KEY `idx_user_type` (`user_type`),
  KEY `idx_status` (`status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户表';
```

#### 1.2 景点表 (sys_attractions)
```sql
CREATE TABLE `sys_attractions` (
  `id` varchar(50) NOT NULL COMMENT '景点ID',
  `name` varchar(200) DEFAULT NULL COMMENT '景点名称',
  `price` decimal(10,2) DEFAULT NULL COMMENT '门票价格',
  `introduce` text COMMENT '景点简介',
  `content` longtext COMMENT '详细介绍',
  `num` int(11) DEFAULT NULL COMMENT '库存数量',
  `images` text COMMENT '景点图片(逗号分隔)',
  `state` int(1) DEFAULT '1' COMMENT '状态(0禁用1启用)',
  `location` varchar(200) DEFAULT NULL COMMENT '景点位置',
  `opening_hours` varchar(100) DEFAULT NULL COMMENT '开放时间',
  `phone` varchar(20) DEFAULT NULL COMMENT '联系电话',
  `rating` decimal(3,2) DEFAULT '0.00' COMMENT '平均评分',
  `review_count` int(11) DEFAULT '0' COMMENT '评论数量',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  KEY `idx_state` (`state`),
  KEY `idx_price` (`price`),
  KEY `idx_rating` (`rating`),
  KEY `idx_create_time` (`create_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='景点表';
```

#### 1.3 景点预约表 (sys_attraction_order)
```sql
CREATE TABLE `sys_attraction_order` (
  `id` varchar(50) NOT NULL COMMENT '预约ID',
  `user_id` varchar(50) DEFAULT NULL COMMENT '用户ID',
  `attractions_id` varchar(50) DEFAULT NULL COMMENT '景点ID',
  `num` int(11) DEFAULT NULL COMMENT '预约人数',
  `time` date DEFAULT NULL COMMENT '预约日期',
  `people` text COMMENT '预约人员信息',
  `total_price` decimal(10,2) DEFAULT NULL COMMENT '总价格',
  `contact_name` varchar(100) DEFAULT NULL COMMENT '联系人姓名',
  `contact_phone` varchar(20) DEFAULT NULL COMMENT '联系人电话',
  `status` int(1) DEFAULT '0' COMMENT '预约状态(0待确认1已确认2已完成3已取消)',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  KEY `idx_user_id` (`user_id`),
  KEY `idx_attractions_id` (`attractions_id`),
  KEY `idx_status` (`status`),
  KEY `idx_time` (`time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='景点预约表';
```

#### 1.4 评论表 (sys_comments)
```sql
CREATE TABLE `sys_comments` (
  `id` varchar(50) NOT NULL COMMENT '评论ID',
  `user_id` varchar(50) DEFAULT NULL COMMENT '用户ID',
  `attractions_id` varchar(50) DEFAULT NULL COMMENT '景点ID',
  `content` text COMMENT '评论内容',
  `rate` int(1) DEFAULT NULL COMMENT '评分(1-5)',
  `images` text COMMENT '评论图片',
  `reply` text COMMENT '管理员回复',
  `status` int(1) DEFAULT '0' COMMENT '状态(0待审核1已通过2已拒绝)',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  KEY `idx_user_id` (`user_id`),
  KEY `idx_attractions_id` (`attractions_id`),
  KEY `idx_status` (`status`),
  KEY `idx_rate` (`rate`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='评论表';
```

### 2. 数据库优化策略

#### 2.1 索引设计
- **主键索引**: 所有表使用字符串主键，提高分布式扩展性
- **唯一索引**: 用户登录账号、邮箱等唯一字段
- **普通索引**: 状态字段、外键字段、时间字段
- **复合索引**: 常用查询条件组合

#### 2.2 数据分页
```java
// 使用MyBatis Plus分页插件
@Configuration
public class MyBatisPlusConfig {
    
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        
        // 分页插件
        PaginationInnerInterceptor paginationInterceptor = new PaginationInnerInterceptor();
        paginationInterceptor.setDbType(DbType.MYSQL);
        paginationInterceptor.setOverflow(false); // 超过最大页数不处理
        paginationInterceptor.setMaxLimit(500L);  // 最大单页限制数量
        
        interceptor.addInnerInterceptor(paginationInterceptor);
        return interceptor;
    }
}
```

#### 2.3 连接池配置
```yaml
spring:
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    druid:
      initialSize: 5          # 初始连接数
      minIdle: 10            # 最小连接池数量
      maxActive: 20          # 最大连接池数量
      maxWait: 60000         # 获取连接等待超时时间(ms)
      timeBetweenEvictionRunsMillis: 60000  # 间隔多久检测需要关闭的连接
      minEvictableIdleTimeMillis: 300000    # 连接在池中最小生存时间
      validationQuery: SELECT 1 FROM DUAL   # 检测连接是否有效的SQL
      testWhileIdle: true     # 申请连接时检测
      testOnBorrow: false     # 归还连接时检测
      testOnReturn: false     # 获取连接时检测
      poolPreparedStatements: true          # 打开PSCache
      maxPoolPreparedStatementPerConnectionSize: 20  # PSCache大小
      
      # 监控配置
      filters: stat,wall,slf4j
      connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000
      
      # Web监控
      web-stat-filter:
        enabled: true
        url-pattern: /*
        exclusions: "*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*"
      
      stat-view-servlet:
        enabled: true
        url-pattern: /druid/*
        reset-enable: false
        login-username: admin
        login-password: admin
```

### 3. 事务管理

#### 3.1 事务配置
```java
@Configuration
@EnableTransactionManagement
public class TransactionConfig {
    
    @Bean
    public PlatformTransactionManager transactionManager(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}
```

#### 3.2 事务使用示例
```java
@Service
@Transactional(rollbackFor = Exception.class)
public class SysAttractionOrderServiceImpl extends ServiceImpl<SysAttractionOrderMapper, SysAttractionOrder> 
        implements ISysAttractionOrderService {
    
    /**
     * 保存预约并扣减库存（事务处理）
     */
    @Override
    @Transactional(rollbackFor = Exception.class)
    public boolean saveOrderAndReduceStock(SysAttractionOrder order, SysAttractions attractions) {
        try {
            // 1. 保存预约订单
            boolean saveResult = this.save(order);
            if (!saveResult) {
                throw new RuntimeException("保存预约订单失败");
            }
            
            // 2. 扣减库存
            attractions.setNum(attractions.getNum() - order.getNum());
            boolean updateResult = sysAttractionsService.updateById(attractions);
            if (!updateResult) {
                throw new RuntimeException("更新库存失败");
            }
            
            // 3. 记录操作日志
            logOperation("用户预约", order.getUserId(), order.getAttractionsId());
            
            return true;
        } catch (Exception e) {
            // 事务回滚
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw e;
        }
    }
}
```

## 部署和运行详解

### 1. 环境要求

#### 1.1 基础环境
- **JDK**: 1.8或更高版本
- **Maven**: 3.6.0或更高版本
- **MySQL**: 5.7或更高版本（推荐8.0+）
- **Redis**: 3.0或更高版本（推荐6.0+）

#### 1.2 服务器配置推荐
- **CPU**: 2核以上
- **内存**: 4GB以上
- **硬盘**: 50GB以上
- **网络**: 100Mbps以上

### 2. 部署步骤详解

#### 2.1 数据库初始化
```sql
-- 1. 创建数据库
CREATE DATABASE `db_tourism` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- 2. 创建用户并授权
CREATE USER 'tourism_user'@'%' IDENTIFIED BY 'tourism_password_2024';
GRANT ALL PRIVILEGES ON db_tourism.* TO 'tourism_user'@'%';
FLUSH PRIVILEGES;

-- 3. 导入表结构和初始数据
USE db_tourism;
SOURCE /path/to/tourism_database.sql;
```

#### 2.2 Redis配置
```bash
# 启动Redis服务
redis-server /etc/redis/redis.conf

# 验证Redis连接
redis-cli ping
```

#### 2.3 项目配置文件
```yaml
# application-prod.yml (生产环境配置)
server:
  port: 8080
  servlet:
    context-path: /api

spring:
  profiles:
    active: prod
  
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    url: jdbc:mysql://localhost:3306/db_tourism?useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai&useSSL=false
    username: tourism_user
    password: tourism_password_2024
    driver-class-name: com.mysql.cj.jdbc.Driver
    
  redis:
    host: localhost
    port: 6379
    database: 0
    password: redis_password_2024
    timeout: 10s
    lettuce:
      pool:
        min-idle: 5
        max-idle: 20
        max-active: 20
        max-wait: 5s

# 日志配置
logging:
  level:
    com.shanzhu.tourism: INFO
    org.springframework.web: INFO
  file:
    path: /var/log/tourism-backend/
    name: tourism-backend.log
  pattern:
    file: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
```

#### 2.4 打包部署
```bash
# 1. 清理并编译项目
mvn clean compile

# 2. 运行测试
mvn test

# 3. 打包应用
mvn clean package -DskipTests

# 4. 启动应用
nohup java -jar target/tourism-backend-1.0.jar --spring.profiles.active=prod > /var/log/tourism-backend/startup.log 2>&1 &

# 5. 检查应用状态
curl http://localhost:8080/api/login/health
```

#### 2.5 Nginx反向代理配置
```nginx
upstream tourism_backend {
    server 127.0.0.1:8080;
    keepalive 32;
}

server {
    listen 80;
    server_name your-domain.com;
    
    location /api/ {
        proxy_pass http://tourism_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_connect_timeout 30s;
        proxy_send_timeout 30s;
        proxy_read_timeout 30s;
    }
    
    # 静态文件服务
    location /upload/ {
        alias /path/to/tourism-backend/static/upload/;
        expires 30d;
        add_header Cache-Control "public, immutable";
    }
}
```

### 3. 监控和维护

#### 3.1 应用监控
```yaml
# application.yml 添加监控配置
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,env
  endpoint:
    health:
      show-details: always
  metrics:
    export:
      prometheus:
        enabled: true
```

#### 3.2 日志监控
```xml
<!-- logback-spring.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <springProfile name="prod">
        <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
            <file>/var/log/tourism-backend/tourism-backend.log</file>
            <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
                <fileNamePattern>/var/log/tourism-backend/tourism-backend.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
                <maxFileSize>100MB</maxFileSize>
                <maxHistory>30</maxHistory>
                <totalSizeCap>3GB</totalSizeCap>
            </rollingPolicy>
            <encoder>
                <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
            </encoder>
        </appender>
        
        <root level="INFO">
            <appender-ref ref="FILE"/>
        </root>
    </springProfile>
</configuration>
```

#### 3.3 数据库备份脚本
```bash
#!/bin/bash
# backup_database.sh

DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/var/backups/tourism"
DB_NAME="db_tourism"
DB_USER="tourism_user"
DB_PASS="tourism_password_2024"

# 创建备份目录
mkdir -p $BACKUP_DIR

# 备份数据库
mysqldump -u$DB_USER -p$DB_PASS $DB_NAME > $BACKUP_DIR/tourism_backup_$DATE.sql

# 压缩备份文件
gzip $BACKUP_DIR/tourism_backup_$DATE.sql

# 删除7天前的备份
find $BACKUP_DIR -name "tourism_backup_*.sql.gz" -mtime +7 -delete

echo "Database backup completed: tourism_backup_$DATE.sql.gz"
```

## 性能优化策略

### 1. 数据库性能优化

#### 1.1 查询优化
```java
// 使用索引优化查询
@Override
public Page<SysAttractions> getAttractionsPage(Page<SysAttractions> page, SysAttractions attractions) {
    QueryWrapper<SysAttractions> queryWrapper = new QueryWrapper<>();
    queryWrapper.lambda()
        // 使用索引字段进行查询
        .eq(attractions.getState() != null, SysAttractions::getState, attractions.getState())
        .like(StringUtils.isNotBlank(attractions.getName()), SysAttractions::getName, attractions.getName())
        // 使用索引排序
        .orderByDesc(SysAttractions::getCreateTime);
    
    return this.page(page, queryWrapper);
}

// 批量操作优化
@Override
@Transactional(rollbackFor = Exception.class)
public boolean batchInsertAttractions(List<SysAttractions> attractionsList) {
    // 使用批量插入提高性能
    return this.saveBatch(attractionsList, 1000); // 每次插入1000条
}
```

#### 1.2 连接池优化
```yaml
spring:
  datasource:
    druid:
      # 连接池配置优化
      initialSize: 10         # 初始连接数
      minIdle: 10            # 最小连接数
      maxActive: 100         # 最大连接数
      maxWait: 10000         # 最大等待时间
      
      # 连接有效性检测
      validationQuery: SELECT 1
      testWhileIdle: true
      testOnBorrow: false
      testOnReturn: false
      
      # 连接池回收
      timeBetweenEvictionRunsMillis: 60000
      minEvictableIdleTimeMillis: 300000
```

### 2. Redis缓存优化

#### 2.1 缓存策略
```java
@Service
public class CacheService {
    
    @Autowired
    private RedisUtils redisUtils;
    
    /**
     * 多级缓存策略
     */
    public SysAttractions getAttractions(String id) {
        // 1. 本地缓存
        SysAttractions cached = localCache.get(id);
        if (cached != null) {
            return cached;
        }
        
        // 2. Redis缓存
        String key = "attractions:" + id;
        String cachedData = redisUtils.get(key);
        if (cachedData != null) {
            SysAttractions attractions = JSON.parseObject(cachedData, SysAttractions.class);
            localCache.put(id, attractions, 300); // 本地缓存5分钟
            return attractions;
        }
        
        // 3. 数据库查询
        SysAttractions attractions = sysAttractionsMapper.selectById(id);
        if (attractions != null) {
            // 缓存到Redis（1小时）
            redisUtils.set(key, JSON.toJSONString(attractions), 3600);
            // 缓存到本地（5分钟）
            localCache.put(id, attractions, 300);
        }
        
        return attractions;
    }
    
    /**
     * 缓存更新策略
     */
    public void updateAttractionsCache(SysAttractions attractions) {
        String key = "attractions:" + attractions.getId();
        
        // 更新Redis缓存
        redisUtils.set(key, JSON.toJSONString(attractions), 3600);
        
        // 清除本地缓存
        localCache.remove(attractions.getId());
        
        // 清除相关列表缓存
        redisUtils.del("attractions:list:*");
    }
}
```

#### 2.2 缓存预热
```java
@Component
public class CacheWarmup {
    
    @PostConstruct
    public void warmupCache() {
        // 预热热门景点数据
        List<SysAttractions> hotAttractions = sysAttractionsService.getHotAttractions();
        for (SysAttractions attractions : hotAttractions) {
            String key = "attractions:" + attractions.getId();
            redisUtils.set(key, JSON.toJSONString(attractions), 3600);
        }
        
        // 预热用户推荐数据
        List<User> activeUsers = userService.getActiveUsers();
        for (User user : activeUsers) {
            List<SysAttractions> recommendations = getRecommendations(user.getId());
            String key = "recommend:attractions:" + user.getId();
            redisUtils.set(key, JSON.toJSONString(recommendations), 7200);
        }
    }
}
```

### 3. 应用性能优化

#### 3.1 异步处理
```java
@Configuration
@EnableAsync
public class AsyncConfig {
    
    @Bean("taskExecutor")
    public ThreadPoolTaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(50);
        executor.setQueueCapacity(200);
        executor.setThreadNamePrefix("tourism-async-");
        executor.setKeepAliveSeconds(60);
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
}

@Service
public class AsyncService {
    
    @Async("taskExecutor")
    public void sendEmailAsync(String email, String content) {
        // 异步发送邮件
        emailService.sendEmail(email, content);
    }
    
    @Async("taskExecutor")
    public void updateRecommendationAsync(String userId) {
        // 异步更新推荐数据
        List<SysAttractions> recommendations = recommendService.generateRecommendations(userId);
        cacheService.updateRecommendationCache(userId, recommendations);
    }
}
```

#### 3.2 接口限流
```java
@Component
public class RateLimitInterceptor implements HandlerInterceptor {
    
    @Autowired
    private RedisUtils redisUtils;
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        String clientIp = getClientIp(request);
        String key = "rate_limit:" + clientIp;
        
        // 获取当前访问次数
        String countStr = redisUtils.get(key);
        int count = countStr == null ? 0 : Integer.parseInt(countStr);
        
        // 限制每分钟100次请求
        if (count >= 100) {
            response.setStatus(429);
            response.setContentType("application/json;charset=UTF-8");
            try {
                response.getWriter().write("{\"message\":\"请求过于频繁，请稍后再试\"}");
            } catch (IOException e) {
                e.printStackTrace();
            }
            return false;
        }
        
        // 增加计数
        if (count == 0) {
            redisUtils.set(key, "1", 60); // 60秒过期
        } else {
            redisUtils.incr(key, 1);
        }
        
        return true;
    }
}
```

## 项目特色功能深度解析

### 1. 智能推荐算法详解

#### 1.1 协同过滤核心算法
```java
public class CoreMath {
    
    /**
     * 计算用户之间的相似度（皮尔逊相关系数）
     */
    public double calculateSimilarity(Map<String, Double> user1Ratings, Map<String, Double> user2Ratings) {
        Set<String> commonItems = new HashSet<>(user1Ratings.keySet());
        commonItems.retainAll(user2Ratings.keySet());
        
        if (commonItems.size() == 0) {
            return 0.0;
        }
        
        double sum1 = 0.0, sum2 = 0.0, sum1Sq = 0.0, sum2Sq = 0.0, pSum = 0.0;
        
        for (String item : commonItems) {
            double rating1 = user1Ratings.get(item);
            double rating2 = user2Ratings.get(item);
            
            sum1 += rating1;
            sum2 += rating2;
            sum1Sq += rating1 * rating1;
            sum2Sq += rating2 * rating2;
            pSum += rating1 * rating2;
        }
        
        double num = pSum - (sum1 * sum2 / commonItems.size());
        double den = Math.sqrt((sum1Sq - sum1 * sum1 / commonItems.size()) * 
                              (sum2Sq - sum2 * sum2 / commonItems.size()));
        
        return den == 0 ? 0 : num / den;
    }
    
    /**
     * 生成推荐列表
     */
    public List<String> recommend(String userId, List<RelateDTO> relates) {
        Map<String, Map<String, Double>> userRatings = buildUserRatingsMatrix(relates);
        Map<String, Double> targetUserRatings = userRatings.get(userId);
        
        if (targetUserRatings == null || targetUserRatings.isEmpty()) {
            return getPopularItems(relates);
        }
        
        // 计算用户相似度
        Map<String, Double> similarities = new HashMap<>();
        for (String otherUserId : userRatings.keySet()) {
            if (!otherUserId.equals(userId)) {
                double similarity = calculateSimilarity(targetUserRatings, userRatings.get(otherUserId));
                if (similarity > 0) {
                    similarities.put(otherUserId, similarity);
                }
            }
        }
        
        // 生成推荐
        Map<String, Double> recommendations = new HashMap<>();
        for (String similarUser : similarities.keySet()) {
            double similarity = similarities.get(similarUser);
            Map<String, Double> similarUserRatings = userRatings.get(similarUser);
            
            for (String item : similarUserRatings.keySet()) {
                if (!targetUserRatings.containsKey(item)) {
                    double rating = similarUserRatings.get(item);
                    recommendations.put(item, recommendations.getOrDefault(item, 0.0) + similarity * rating);
                }
            }
        }
        
        // 排序并返回前N个推荐
        return recommendations.entrySet().stream()
                .sorted(Map.Entry.<String, Double>comparingByValue().reversed())
                .limit(10)
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());
    }
}
```

### 2. 文件上传安全机制

#### 2.1 文件上传安全验证
```java
@Component
public class FileUploadService {
    
    private static final List<String> ALLOWED_IMAGE_TYPES = Arrays.asList(
        "image/jpeg", "image/jpg", "image/png", "image/gif", "image/webp", "image/bmp"
    );
    
    private static final List<String> ALLOWED_EXTENSIONS = Arrays.asList(
        ".jpg", ".jpeg", ".png", ".gif", ".webp", ".bmp"
    );
    
    private static final long MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
    
    public String uploadImage(MultipartFile file) throws IOException {
        // 1. 基础验证
        if (file.isEmpty()) {
            throw new IllegalArgumentException("文件不能为空");
        }
        
        // 2. 文件大小验证
        if (file.getSize() > MAX_FILE_SIZE) {
            throw new IllegalArgumentException("文件大小不能超过10MB");
        }
        
        // 3. 文件类型验证
        String contentType = file.getContentType();
        if (!ALLOWED_IMAGE_TYPES.contains(contentType)) {
            throw new IllegalArgumentException("不支持的文件类型");
        }
        
        // 4. 文件扩展名验证
        String originalFilename = file.getOriginalFilename();
        String extension = originalFilename.substring(originalFilename.lastIndexOf(".")).toLowerCase();
        if (!ALLOWED_EXTENSIONS.contains(extension)) {
            throw new IllegalArgumentException("不支持的文件扩展名");
        }
        
        // 5. 文件内容验证（防止文件伪造）
        if (!isValidImageFile(file)) {
            throw new IllegalArgumentException("文件内容验证失败");
        }
        
        // 6. 生成安全的文件名
        String filename = generateSecureFilename(extension);
        
        // 7. 创建上传目录
        String uploadPath = createUploadDirectory();
        
        // 8. 保存文件
        File targetFile = new File(uploadPath, filename);
        file.transferTo(targetFile);
        
        // 9. 生成缩略图（可选）
        generateThumbnail(targetFile);
        
        return "/upload/images/" + filename;
    }
    
    private boolean isValidImageFile(MultipartFile file) {
        try {
            BufferedImage image = ImageIO.read(file.getInputStream());
            return image != null;
        } catch (IOException e) {
            return false;
        }
    }
    
    private String generateSecureFilename(String extension) {
        return UUID.randomUUID().toString().replaceAll("-", "") + "_" + 
               System.currentTimeMillis() + extension;
    }
}
```

### 3. 多级缓存架构

#### 3.1 缓存架构设计
```java
@Component
public class MultiLevelCacheService {
    
    // 本地缓存（Caffeine）
    private final Cache<String, Object> localCache = Caffeine.newBuilder()
            .maximumSize(10000)
            .expireAfterWrite(5, TimeUnit.MINUTES)
            .recordStats()
            .build();
    
    @Autowired
    private RedisUtils redisUtils;
    
    /**
     * 多级缓存获取
     */
    public <T> T get(String key, Class<T> clazz, Supplier<T> dataLoader) {
        // 1. 本地缓存
        T localValue = (T) localCache.getIfPresent(key);
        if (localValue != null) {
            return localValue;
        }
        
        // 2. Redis缓存
        String redisValue = redisUtils.get(key);
        if (redisValue != null) {
            T value = JSON.parseObject(redisValue, clazz);
            localCache.put(key, value);
            return value;
        }
        
        // 3. 数据源
        T value = dataLoader.get();
        if (value != null) {
            // 缓存到Redis（1小时）
            redisUtils.set(key, JSON.toJSONString(value), 3600);
            // 缓存到本地（5分钟）
            localCache.put(key, value);
        }
        
        return value;
    }
    
    /**
     * 缓存更新
     */
    public void put(String key, Object value, long redisExpire) {
        // 更新Redis
        redisUtils.set(key, JSON.toJSONString(value), redisExpire);
        // 更新本地缓存
        localCache.put(key, value);
    }
    
    /**
     * 缓存失效
     */
    public void evict(String key) {
        redisUtils.del(key);
        localCache.invalidate(key);
    }
}
```

## 总结

汉中旅游服务平台后端项目是一个功能完善、架构清晰、技术先进的现代化旅游服务系统。项目具有以下核心特点：

### 1. 完整的业务功能体系
- **17个核心业务模块**：涵盖用户管理、景点推荐、酒店预订、美食指南、文化活动、智能推荐等全方位旅游服务
- **60+个API接口**：提供完整的RESTful API，支持Web端和移动端应用
- **智能推荐系统**：基于协同过滤算法的个性化景点推荐
- **完善的预约系统**：支持景点门票预约、酒店房间预订，自动库存管理

### 2. 先进的技术架构
- **Spring Boot 2.4.2**：现代化的Java开发框架，提供自动配置和快速开发能力
- **MyBatis Plus 3.4.1**：强大的ORM框架，简化数据库操作，支持代码生成和条件构造器
- **Redis缓存体系**：多级缓存架构，显著提升系统性能
- **JWT认证机制**：无状态的用户认证，支持分布式部署

### 3. 健壮的安全机制
- **多层密码保护**：加盐哈希算法，BCrypt加密存储
- **JWT Token认证**：安全的用户身份验证，支持Token过期和刷新
- **接口权限控制**：Token拦截器，细粒度的接口访问控制
- **SQL注入防护**：使用参数化查询和条件构造器
- **文件上传安全**：严格的文件类型验证和内容检查

### 4. 高性能设计
- **数据库优化**：合理的索引设计、连接池优化、分页查询
- **缓存策略**：本地缓存+Redis分布式缓存的多级缓存架构
- **异步处理**：异步邮件发送、推荐算法计算等耗时操作
- **接口限流**：基于Redis的分布式限流机制

### 5. 可扩展的架构设计
- **分层架构**：清晰的Controller-Service-Mapper三层架构
- **模块化设计**：17个独立的业务模块，易于维护和扩展
- **配置化管理**：多环境配置支持，便于部署和运维
- **监控体系**：完善的日志记录、性能监控、健康检查

### 6. 开发友好特性
- **统一返回格式**：标准化的API响应格式
- **全局异常处理**：统一的异常处理机制
- **代码生成器**：MyBatis Plus代码生成，提高开发效率
- **完善的文档**：详细的接口文档和代码注释

### 7. 生产环境就绪
- **容器化支持**：支持Docker部署
- **负载均衡**：支持Nginx反向代理和负载均衡
- **数据备份**：自动化数据库备份策略
- **监控告警**：应用监控、性能指标、日志分析

该项目不仅具备完整的旅游服务功能，还采用了现代化的技术栈和最佳实践，具有良好的可维护性、可扩展性和安全性。无论是作为学习现代Java Web开发的参考项目，还是作为实际的旅游服务平台，都具有很高的价值。项目的智能推荐算法、多级缓存架构、安全认证机制等技术特性，展现了当前企业级Java应用开发的技术水准。